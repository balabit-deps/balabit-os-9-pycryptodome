From 519e7aea6de4e8f03b62c6e1dba724aca738882e Mon Sep 17 00:00:00 2001
From: Helder Eijs <helderijs@gmail.com>
Date: Mon, 25 Dec 2023 14:49:23 +0100
Subject: [PATCH] Avoid changing signature of RSA._decrypt() method if possible

---
 lib/Crypto/Cipher/PKCS1_OAEP.py                  | 2 +-
 lib/Crypto/Cipher/PKCS1_v1_5.py                  | 2 +-
 lib/Crypto/PublicKey/RSA.py                      | 7 ++++++-
 lib/Crypto/SelfTest/PublicKey/test_RSA.py        | 8 ++++++--
 lib/Crypto/SelfTest/PublicKey/test_import_RSA.py | 4 ++--
 lib/Crypto/Signature/pkcs1_15.py                 | 2 +-
 lib/Crypto/Signature/pss.py                      | 2 +-
 7 files changed, 18 insertions(+), 9 deletions(-)

--- a/lib/Crypto/Cipher/PKCS1_OAEP.py
+++ b/lib/Crypto/Cipher/PKCS1_OAEP.py
@@ -168,7 +168,7 @@ class PKCS1OAEP_Cipher:
         # Step 2a (O2SIP)
         ct_int = bytes_to_long(ciphertext)
         # Step 2b (RSADP) and step 2c (I2OSP)
-        em = self._key._decrypt(ct_int)
+        em = self._key._decrypt_to_bytes(ct_int)
         # Step 3a
         lHash = self._hashObj.new(self._label).digest()
         # Step 3b
--- a/lib/Crypto/Cipher/PKCS1_v1_5.py
+++ b/lib/Crypto/Cipher/PKCS1_v1_5.py
@@ -177,7 +177,7 @@ class PKCS115_Cipher:
         ct_int = bytes_to_long(ciphertext)
 
         # Step 2b (RSADP) and Step 2c (I2OSP)
-        em = self._key._decrypt(ct_int)
+        em = self._key._decrypt_to_bytes(ct_int)
 
         # Step 3 (not constant time when the sentinel is not a byte string)
         output = bytes(bytearray(k))
--- a/lib/Crypto/PublicKey/RSA.py
+++ b/lib/Crypto/PublicKey/RSA.py
@@ -150,7 +150,7 @@ class RsaKey(object):
             raise ValueError("Plaintext too large")
         return int(pow(Integer(plaintext), self._e, self._n))
 
-    def _decrypt(self, ciphertext):
+    def _decrypt_to_bytes(self, ciphertext):
         if not 0 <= ciphertext < self._n:
             raise ValueError("Ciphertext too large")
         if not self.has_private():
@@ -175,6 +175,11 @@ class RsaKey(object):
                     self._n)
         return result
 
+    def _decrypt(self, ciphertext):
+        """Legacy private method"""
+
+        return bytes_to_long(self._decrypt_to_bytes(ciphertext))
+
     def has_private(self):
         """Whether this is an RSA private key"""
 
--- a/lib/Crypto/SelfTest/PublicKey/test_RSA.py
+++ b/lib/Crypto/SelfTest/PublicKey/test_RSA.py
@@ -214,9 +214,11 @@ class RSATest(unittest.TestCase):
         rsa_obj = self.rsa.generate(1024)
 
         self.assertRaises(ValueError, rsa_obj._decrypt, rsa_obj.n)
+        self.assertRaises(ValueError, rsa_obj._decrypt_to_bytes, rsa_obj.n)
         self.assertRaises(ValueError, rsa_obj._encrypt, rsa_obj.n)
 
         self.assertRaises(ValueError, rsa_obj._decrypt, -1)
+        self.assertRaises(ValueError, rsa_obj._decrypt_to_bytes, -1)
         self.assertRaises(ValueError, rsa_obj._encrypt, -1)
 
     def test_size(self):
@@ -262,6 +264,8 @@ class RSATest(unittest.TestCase):
         # Public keys should not be able to sign or decrypt
         self.assertRaises(TypeError, rsaObj._decrypt,
                 bytes_to_long(ciphertext))
+        self.assertRaises(TypeError, rsaObj._decrypt_to_bytes,
+                bytes_to_long(ciphertext))
 
         # Check __eq__ and __ne__
         self.assertEqual(rsaObj.public_key() == rsaObj.public_key(),True) # assert_
@@ -276,7 +280,7 @@ class RSATest(unittest.TestCase):
         ciphertext = bytes_to_long(a2b_hex(self.ciphertext))
 
         # Test decryption
-        plaintext = bytes_to_long(rsaObj._decrypt(ciphertext))
+        plaintext = rsaObj._decrypt(ciphertext)
 
         # Test encryption (2 arguments)
         new_ciphertext2 = rsaObj._encrypt(plaintext)
@@ -301,7 +305,7 @@ class RSATest(unittest.TestCase):
         ciphertext = bytes_to_long(a2b_hex(self.ciphertext))
 
         # Test plain decryption
-        new_plaintext = bytes_to_long(rsaObj._decrypt(ciphertext))
+        new_plaintext = rsaObj._decrypt(ciphertext)
         self.assertEqual(plaintext, new_plaintext)
 
 
--- a/lib/Crypto/SelfTest/PublicKey/test_import_RSA.py
+++ b/lib/Crypto/SelfTest/PublicKey/test_import_RSA.py
@@ -239,13 +239,13 @@ Lr7UkvEtFrRhDDKMtuIIq19FrL4pUIMymPMSLBn3
     def testImportKey5(self):
         """Verifies that the imported key is still a valid RSA pair"""
         key = RSA.importKey(self.rsaKeyPEM)
-        idem = key._encrypt(bytes_to_long(key._decrypt(89)))
+        idem = key._encrypt(key._decrypt(89))
         self.assertEqual(idem, 89)
 
     def testImportKey6(self):
         """Verifies that the imported key is still a valid RSA pair"""
         key = RSA.importKey(self.rsaKeyDER)
-        idem = key._encrypt(bytes_to_long(key._decrypt(65)))
+        idem = key._encrypt(key._decrypt(65))
         self.assertEqual(idem, 65)
 
     def testImportKey7(self):
--- a/lib/Crypto/Signature/pkcs1_15.py
+++ b/lib/Crypto/Signature/pkcs1_15.py
@@ -78,7 +78,7 @@ class PKCS115_SigScheme:
         # Step 2a (OS2IP)
         em_int = bytes_to_long(em)
         # Step 2b (RSASP1) and Step 2c (I2OSP)
-        signature = self._key._decrypt(em_int)
+        signature = self._key._decrypt_to_bytes(em_int)
         # Verify no faults occurred
         if em_int != pow(bytes_to_long(signature), self._key.e, self._key.n):
             raise ValueError("Fault detected in RSA private key operation")
--- a/lib/Crypto/Signature/pss.py
+++ b/lib/Crypto/Signature/pss.py
@@ -108,7 +108,7 @@ class PSS_SigScheme:
         # Step 2a (OS2IP)
         em_int = bytes_to_long(em)
         # Step 2b (RSASP1) and Step 2c (I2OSP)
-        signature = self._key._decrypt(em_int)
+        signature = self._key._decrypt_to_bytes(em_int)
         # Verify no faults occurred
         if em_int != pow(bytes_to_long(signature), self._key.e, self._key.n):
             raise ValueError("Fault detected in RSA private key operation")
